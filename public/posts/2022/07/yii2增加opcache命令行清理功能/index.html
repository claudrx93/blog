<!doctype html><html lang=zh><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Yii2增加opcache命令行清理功能 | 9995空间</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="opcache作为PHP的重要加速功能，可以在生产环境上大大地提升运行速度。如非极度追求速度需要上CLI类的框架，一般生产环境开启opcache即可。
opcache的功能不再叙述，可以参考此文（ https://segmentfault.com/a/1190000023731765?utm_source=tag-newest ）。
opcache的效果立竿见影，但是有一个很严重的问题。就是php-fpm的缓存，只能在php-fpm运行php脚本进行清理。简单来说，就是必须暴露一个接口进行浏览器访问才能清理，而不能在命令行完成。Cli的opcache缓存与fpm的opcache缓存是完全独立的。下面就简单介绍一下在YII2如何利用命令行进行解决。"><meta name=generator content="Hugo 0.147.6"><meta name=robots content="noindex, nofollow"><meta name=author content="Miantu"><link rel=stylesheet href=/ananke/css/main.min.css><link rel=canonical href=http://localhost:1313/posts/2022/07/yii2%E5%A2%9E%E5%8A%A0opcache%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B8%85%E7%90%86%E5%8A%9F%E8%83%BD/><meta property="og:url" content="http://localhost:1313/posts/2022/07/yii2%E5%A2%9E%E5%8A%A0opcache%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B8%85%E7%90%86%E5%8A%9F%E8%83%BD/"><meta property="og:site_name" content="9995空间"><meta property="og:title" content="Yii2增加opcache命令行清理功能"><meta property="og:description" content="opcache作为PHP的重要加速功能，可以在生产环境上大大地提升运行速度。如非极度追求速度需要上CLI类的框架，一般生产环境开启opcache即可。
opcache的功能不再叙述，可以参考此文（ https://segmentfault.com/a/1190000023731765?utm_source=tag-newest ）。
opcache的效果立竿见影，但是有一个很严重的问题。就是php-fpm的缓存，只能在php-fpm运行php脚本进行清理。简单来说，就是必须暴露一个接口进行浏览器访问才能清理，而不能在命令行完成。Cli的opcache缓存与fpm的opcache缓存是完全独立的。下面就简单介绍一下在YII2如何利用命令行进行解决。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-26T12:03:54+08:00"><meta property="article:modified_time" content="2022-07-26T12:03:54+08:00"><meta property="article:tag" content="Yii"><meta property="article:tag" content="Opcache"><meta property="article:tag" content="Php"><meta itemprop=name content="Yii2增加opcache命令行清理功能"><meta itemprop=description content="opcache作为PHP的重要加速功能，可以在生产环境上大大地提升运行速度。如非极度追求速度需要上CLI类的框架，一般生产环境开启opcache即可。
opcache的功能不再叙述，可以参考此文（ https://segmentfault.com/a/1190000023731765?utm_source=tag-newest ）。
opcache的效果立竿见影，但是有一个很严重的问题。就是php-fpm的缓存，只能在php-fpm运行php脚本进行清理。简单来说，就是必须暴露一个接口进行浏览器访问才能清理，而不能在命令行完成。Cli的opcache缓存与fpm的opcache缓存是完全独立的。下面就简单介绍一下在YII2如何利用命令行进行解决。"><meta itemprop=datePublished content="2022-07-26T12:03:54+08:00"><meta itemprop=dateModified content="2022-07-26T12:03:54+08:00"><meta itemprop=wordCount content="149"><meta itemprop=keywords content="Yii,Opcache,Php"><meta name=twitter:card content="summary"><meta name=twitter:title content="Yii2增加opcache命令行清理功能"><meta name=twitter:description content="opcache作为PHP的重要加速功能，可以在生产环境上大大地提升运行速度。如非极度追求速度需要上CLI类的框架，一般生产环境开启opcache即可。
opcache的功能不再叙述，可以参考此文（ https://segmentfault.com/a/1190000023731765?utm_source=tag-newest ）。
opcache的效果立竿见影，但是有一个很严重的问题。就是php-fpm的缓存，只能在php-fpm运行php脚本进行清理。简单来说，就是必须暴露一个接口进行浏览器访问才能清理，而不能在命令行完成。Cli的opcache缓存与fpm的opcache缓存是完全独立的。下面就简单介绍一下在YII2如何利用命令行进行解决。"></head><body class="ma0 avenir bg-near-white development"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">9995空间</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/posts/ title="文章 页">文章</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/travel/ title="游记 页">游记</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/categories/ title="栏目 页">栏目</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Yii2增加opcache命令行清理功能</h1><p class=tracked><strong>Miantu</strong></p><time class="f6 mv4 dib tracked" datetime=2022-07-26T12:03:54+08:00>七月 26, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>opcache作为PHP的重要加速功能，可以在生产环境上大大地提升运行速度。如非极度追求速度需要上CLI类的框架，一般生产环境开启opcache即可。</p><p>opcache的功能不再叙述，可以参考此文（ <a href="https://segmentfault.com/a/1190000023731765?utm_source=tag-newest">https://segmentfault.com/a/1190000023731765?utm_source=tag-newest</a> ）。</p><p>opcache的效果立竿见影，但是有一个很严重的问题。就是php-fpm的缓存，只能在php-fpm运行php脚本进行清理。简单来说，就是必须暴露一个接口进行浏览器访问才能清理，而不能在命令行完成。Cli的opcache缓存与fpm的opcache缓存是完全独立的。下面就简单介绍一下在YII2如何利用命令行进行解决。</p><ol><li>在frontend的模块创建可访问控制器，定义该控制器只能127.0.0.1（内网）才能访问。代码如下：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74> * Opcache控制器
</span></span></span><span style=display:flex><span><span style=color:#e6db74> *
</span></span></span><span style=display:flex><span><span style=color:#e6db74> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OpcacheController</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>yii\rest\Controller</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> $optional <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;reset&#39;</span>,
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * 重置
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     *
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @return void
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>actionReset</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>\Yii</span><span style=color:#f92672>::</span>$app<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>request</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>hostName</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;127.0.0.1&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NotFoundHttpException</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>function_exists</span>(<span style=color:#e6db74>&#39;opcache_reset&#39;</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>opcache_reset</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>success</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>error</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>讲解：这里是使用了REST控制器，并且声明了reset方法不用权限验证即可访问。</p><p>2、在connsole的模块创建可访问控制器，使用Curl远程访问frontend的opcache控制器对字节码缓存进行清理。代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OpcacheController</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>yii\console\Controller</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> $baseUrl <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://127.0.0.1&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	 * 重置
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>actionReset</span>($baseUrl <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		$baseUrl <span style=color:#f92672>=</span> $baseUrl <span style=color:#f92672>?:</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>baseUrl</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>// exec(&#39;curl &#39; . $baseUrl . &#39;/opcache/reset&#39;, $result);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		$client <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>yii\httpclient\Client</span>();
</span></span><span style=display:flex><span>		$response <span style=color:#f92672>=</span> $client<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>get</span>($baseUrl <span style=color:#f92672>.</span> <span style=color:#e6db74>&#39;/opcache/reset&#39;</span>)<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>send</span>();
</span></span><span style=display:flex><span>		$result <span style=color:#f92672>=</span> <span style=color:#a6e22e>json_decode</span>($response<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getContent</span>());
</span></span><span style=display:flex><span>		<span style=color:#75715e>// $result = json_decode($result[0] ?? &#39;&#39;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> ($result) {
</span></span><span style=display:flex><span>			$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>stdout</span>(<span style=color:#e6db74>&#39;操作成功!&#39;</span> <span style=color:#f92672>.</span> <span style=color:#a6e22e>PHP_EOL</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>stdout</span>(<span style=color:#e6db74>&#39;操作失败!&#39;</span> <span style=color:#f92672>.</span> <span style=color:#a6e22e>PHP_EOL</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>讲解：实现远程访问的方式有多样，方法一是curl直接访问（无需PHP，但是服务器必须先安装curl），方法二是使用php的执行exec命令，方法三是使用php脚本。</p><p>方法一：</p><p>优点：curl直接访问运行速度快，例 curl 127.0.0.1/opcache/reset</p><p>缺点：要求服务器必须先安装curl,并且每次都需要手敲命令行，敲错是在所难免，或者写称sh脚本</p><p>方法二：</p><p>优点：php的执行exec命令，执行的命令同方法一。也是执行速度相对更快，能使用参数输入地址，例php yii /opcache/reset （127.0.0.1：xxxx）,也可以自定义baseUrl。</p><p>缺点：要求服务器必须先安装curl,并且方法二的本质还是方法一，如果追求速度不如直接用方法一。</p><p>方法三：</p><p>优点：使用yii\httpclient\Client进行请求，服务器是否安装curl不影响，并且具备配置设置baseUrl的灵活性，能使用参数输入地址，例php yii /opcache/reset （127.0.0.1：xxxx）。</p><p>缺点：执行速度是三种方式重最慢的。</p><p>本人最终采用方法三，是感觉竟然采用yii2编写命令行脚本，还使用exec执行的话，那不如直接写curl的命令，或者sh脚本。采用方法三的方式编写后，还可以分享给大家使用。</p><p>服务器每次更新代码后，只需要执行php yii /opcache/reset即可。如果非80端口，请自行预配置。但是如果觉得上面的命令行还是太长的话，本人还会写一层npm的scripts简化脚本(&ldquo;oc&rdquo;: &ldquo;php yii /opcache/reset&rdquo;,)，直接执行npm run oc。</p><p>果然懒惰才是促进科技发展的动力（笑）。</p><ul class=pa0><li class="list di"><a href=/tags/yii/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Yii</a></li><li class="list di"><a href=/tags/opcache/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Opcache</a></li><li class="list di"><a href=/tags/php/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Php</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">相关內容</p><ul class="pa0 list"><li class=mb2><a href=/posts/2022/02/yii2%E5%9B%BD%E5%86%85composer%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/>Yii2国内composer安装速度优化</a></li><li class=mb2><a href=/posts/2022/07/yii2%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9docker%E6%96%B9%E6%A1%88/>Yii2使用官方docker方案</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=http://localhost:1313/>&copy; 9995空间 2026</a><div><div class=ananke-socials></div></div></div></footer></body></html>